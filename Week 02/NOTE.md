## 寻路算法
> 一万格的地图

### 地图编辑器
1. 数据结构 一维数组保存
2. fill(0)比较新的API，如果JS的版本不够的话就不能用fill
3. 这里用的是两层for循环，其实用一层也可以，就是要反算x和y（问：怎么改成一层数组？）
4. 用 mousedown 和 mousemove
5. 左键是建墙，右键是清除
6. 注意：因为要使用右键，所以加上e.preventDefault()，否则会弹出菜单
7. 用 localStorage['map'] 来保存地图

### 广度优先搜索
1. 从起点能走到哪去？（走到1234）从1能走到哪去？（走到567）然后算2、3、4 。。。不断地把上下左右的点加到集合里。。。
2. 如果用递归，就变成深度优先搜索，但是寻路用深度优先算法是不好的
3. 所有算法的差异：queue
4. queue是一种数据结构，先进先出。
5. js的数组是一个天然的队列，也是一个天然的栈，js数组有shift、unshift，和push、pop两组方法。如果push和shift相对，就是一个队列，pop和unshift联合使用，就是队列，如果push和pop是栈，shift和unshift是栈，但是一般不会用shift和unshif一起用，性能会变低
6. 我们这里选择的是shift和push作为入队和出队的方法
7. 首先给queue加start，然后把start周围的四个点加进队列，然后逐个把这个周围的点加入队列
8. insert就是入队的逻辑
9. 如果找到了新的节点，就在地图上标记一个新的状态2.接下来就把这个点入队就可以了
10. 如果把push和shift改成push和pop就变成了深度优先搜索

### 异步编程可视化寻路算法
> 最短路径
1. 用 async await
2. 为了把所有的childNodes跟map上的严格对应，div中不能有回车换行，否则就差了一个文本节点，顺序就不一样了


### 处理路径问题
1. typeof Object 和 typeof null 都是返回 object
2. 把pre传进去，把pre写进表格里，最后沿着 pre 的这样一个链路，去找它的路径

### 启发式寻路
> 两点之间直线最短
1. 只要你这个启发式函数，它所使用的估值只要能够一定小于 点到终点的距离，那么它就是能找到最优路径（A*）
2. Sortd 一个排好序的数据结构，能保证每次take的时候总是拿出来一个最小的，每次give（往里塞）的时候我们不管（winner tree、heap堆、二叉树）
3. 要求尽量少挪动元素，每次找最小
4. splice 每次删除的时候会导致后面的元素向前挪，是一个O(n)的操作， 而我们希望是一个O(1)的操作，所以我们的把它跟最后一个元素交换
5. push是成本最小的一个写操作
